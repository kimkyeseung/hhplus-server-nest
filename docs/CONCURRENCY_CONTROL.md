# 콘서트 예약 시나리오에서 발생할 수 있는 동시성 이슈 분석 및 해결 방안

## 좌석 선점

여러 사용자가 동시에 좌석을 예약하려고 시도하면, 예약 가능 좌석 수를 초과하거나 동일 좌석에 중복으로 예약이 발생할 수 있음.

### 해결 방안 및 분석:

1. 낙관적 락

- `TicketEntity`에 `version` 필드 추가, 다른 수정요청이 오면 `version`을 확인에서 예외처리.
- 많은 사람들이 동시에 시도하는 하는 좌석 선점의 경우 -> 1명을 제외한 나머지가 실패처리 및 재시도로 인한 성능 이슈 발생 가능
- 구현 난도: 상대적으로 어렵지 않다.

2. 비관적 락

- 데이터를 조회하는 시점부터 트랜잭션을 끝내는 순간까지 데이터에 락을 걸어서 보호.
- 구현 난도:
  - TypeOrm을 사용하는 경우 { mode: 'pessimistic_write' } 옵션을 이용하여 어렵지 않게 락을 구현할 수 있음
  - 요청한 호출의 수에 따라 대기 시간 계산 및 측정이 어려울 수 있음
  - 유저가 대기 하는 동안에 별도의 ux가 필요

3. 분산 락(비관락)

- Redis의 redlock을 이용한 분산 락(비관) 구현
- 구현 난도:
  - Redis의 숙련도에 따라 달렸지만 비관적 락을 구현하는 것에 비해 쉽게 느껴짐

### 최적의 해결 방법:

- 좌석 선점 시나리오의 경우 한 좌석 데이터에 대해 여러 명의 유저가 접근 시도를 하기 때문에 비관적 락을 이용하는 것이 적합하고, Redis를 이용한 비관적 락(redlock) 로직을 직접 구현할 필요없이 모듈을 이용해서 빠른 속도로 처리가 가능하다.

---

## 유저 포인트 잔액

### 해결 방안 및 분석:

1. 낙관적 락

- `PointEntity`에 `version` 필드 추가, 다른 수정요청이 오면 `version`을 확인에서 예외처리. 혹은 새로운 데이터를 확인 후 다른 수정 요청 처리.
- 구현 난도: 상대적으로 어렵지 않다.

2. 비관적 락

- 포인트 조회 및 충전 시 락 설정.
- 트랜잭션이 완전히 끝난 후 락 해제.
- 충돌 가능성이 높은 상황에서 데이터 무결성을 강력히 보장.
- 다른 요청은 대기 해야하므로 처리 속도가 느려짐

3. 분산 락(낙관락)
- WATCH로 키 모니터링:
  - 특정 Redis 키(user:points:{userId})를 WATCH하여 다른 클라이언트의 변경 여부를 감시.
- 현재 값 읽기:
  - WATCH로 설정한 키의 현재 값을 읽어와 포인트를 계산.
- 트랜잭션 시작 (MULTI):
  - 여러 명령어를 트랜잭션으로 묶기 위해 MULTI 명령어를 호출.
- EXEC로 트랜잭션 실행:
  - 트랜잭션 실행 시, WATCH로 모니터링한 키가 변경되지 않았을 때만 성공적으로 수행.
  - 키가 변경되었다면 EXEC 결과가 null로 반환되고, 트랜잭션이 실패.
- 재시도:
  - 트랜잭션 실패 시(EXEC 결과가 null), 루프를 통해 작업을 다시 시도.
- UNWATCH:
  - 트랜잭션 실패 또는 완료 후 WATCH를 해제.

### 최적의 해결 방법:

- 포인트 충전,사용의 경우 동시성 이슈가 있다하더라도 한 계정이 다른 브라우저나 디바이스로 시도함으로써 생기는 이슈로 예상되므로 Redis 낙관적 락의 장점을 이용해서 빠른 성능고 효율적인 동시성 처리를 가능하는것이 최적이라고 생각한다.